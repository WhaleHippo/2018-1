용어 정리
Thrashing : 
Working Set(WS) : 어느 시점에 특정 프로세스가 엑세스하는 page의 집합 = 그 시점의 locaility
에프터 런치 신드롬 : 점심 먹고 왔더니 프로그램 느려지는 느낌. 롱텀 스케쥴러 땜시그럼.
숏텀 스케쥴러 : 프로세스 선택
롱텀 스케쥴러 : 멀티프로그램 정도를 낮추는 것 : 프로세스 모니터링하다 안쓰는놈 내보내기.

내용 정리
-Thrashing 이란
디컴포지션으로 구한 각각의 최적 솔루션이 전체 시스템의 최적 결과를 주는 것은 아니다.
Thrashing 역시 이와 비슷한 사례인데 메모리와 스케쥴링의 최적화가 충돌한 결과다.

프로세스가 많다. -> 요구 페이지가 많다. -> 페이지 폴트가 자주 발생 -> cpu가 idle하는 시간이 많아 사용률이 적다. -> 스케쥴링 최적화에 의해, cpu 사용률을 높이려고 프로세스를 더 요구한다. -> 프로세스가 더 많다. -> 요구 페이지가 더 증가한다. -> 페이지 폴트가 더 자주 발생... 반복...
이건 글로벌 페이지 할당 스타일이다.
그럼 지역(per job/process) 할당 스타일을 하면? 그래도 도움은 안된다. 메모리가 애초에 부족한 상황이니

-Thrashing의 본질적인 이유 : 필요한 메모리보다 메인 메모리가 더 적으니까.
따라서 해결하려면 프로세스를 적절하게 줄이면 된다. 유저 컴이라면 이걸 유저가 알아서 할 수 있지만, 서버 컴이면 사람이 해줘야한다.
스마트폰이나 TV는 스왑이란게 없지만 그래도 Thrashing이 있다. 왜냐면 필요 메모리가 더 커서

-working set : 어느 시점에 특정 프로세스가 엑세스하는 page의 집합 = 그 시점의 locaility
Thrashing을 해결하기 위한 기법. 사실상 구현이 불가능. 미래예지가 필요하니. 이거도 근사해서 과거를 보아서 본다.

1. 워킹셋 파라미터를 통해서. 과거 t시간동안 엑세스된 페이지를 working set이라 생각
t의 단위는 시간이 아니라 페이지 레퍼런스 수로. 단 이거도 코드 세그먼트에 대해선 노카운트임.
t가 작으면 : 충분한 워킹셋을 파악 불가
t가 크면 : 불필요한 페이지도 포함
사실상 제대로된 구현 불가

2. 레퍼런스 비트를 이용 : 만회의 레퍼런스 중에서 레퍼런스비트를 몇번 이용하는가

3. Resident set : Vax에서 쓴 기법
만약에, 현재 메모리에 존재하는 프로세스들이 쓰레싱 없이 잘 돌고 있으면(페이지 폴트가 없으면), 현재 메인 메모리들이 working set일 가능성이 높다. 지역 할당 스타일을 한다. 또한 페이지 폴트의 상한과 하한을 둬서 페이지 폴트를 조절. 이때의 메인메모리의 집합을 working set의 근사고 이걸 레지던스 set이라고 한다.
이런 레저던스 set은 롱텀 스케쥴러에 의해서 프로세스가 나갔다 들어올때 불러오는 걸로 적용가능하다.


-Thrashing과 WS
현재 모든 프로세스의 WS의 합 < 메인 메모리 : Thrashing 발생 안함
현재 모든 프로세스의 WS의 합 > 메인 메모리 : Thrashing 발생 함
