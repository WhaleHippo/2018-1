단어 정리
Heap
fragmentation
Activation Records(stack/activation frames) : 특정 함수,명령어가 수행되기 위해 필요한 정보들의 데이터 구조로 스택에 저장된다. 해당함수의 라이프 사이클과 생사를 같이함.
HEAP
free list : 힙의 사용 가능한 공간들을 링크드 리스트 형태로 연결한 리스트

내용 정리
-동적이란 무엇인가?
런타임 시점을 기준으로 구분한다.
	Static : 런타임 전에 진행 : 코드, 데이타 세그먼트
	Dynamic : 런타임에 진행 : 스택/힙 세그먼트

Static allocation의 특징 : 변수의 라이프 사이클이 프로그램의 시작과 종료와 일치
Dynamic allocation의 특징 : 안 일치

-dynamic allocation의 필요성
런타임 전에 예측 불가 : 액티베이션 레코드의 호출 순서가 예측 불가, 데이터 사용량 예측 불가

-dynamic allocation의 2가지 방법, stack과 heap
1. stack : 굉장히 제약적, PUSH POP이 제약적. 하지만 그런 제약이 때로는 로지컬한 도움이 됨
2. heap : stack보다 일반적이지만 그렇기에 발생하는 문제들도 있음. 이후 내용에선 힙에 대해서 중점적으로 파고들어보자.

-메모리 관련 중요한 기능 2개 : 메모리 줘(new), 메모리 반납할께(delete)


-Heap Management
우선 Heap이란게 뭔지 제대로 이해하자. 자료구조에서 하는 그런 heap tree와는 다르다.
Heap은, 연속적인 메모리 블록이다. 그리고 동적할당시 자신의 일부를 할당한다. 초기에는 연속적으로 할당하지만, 누군가가 메모리를 반납하면 빈공간(Hole)들이 생긴다. 이런 빈 공간들을 원활하게 이용하기 위해서, Free List를 만들어서 이용한다.

Free List의 깔끔한 구성을 위해서, 반납되는 메모리가 기존의 Free list의 반납된 메모리들과 병합이 가능하다면 병합한다. 아닐 경우 그냥 추가해야지 뭐.

근데 이게 계속되면 힙에 Hole들이 마구마구 생긴다. 궁극적으로 작은 Hole이 왕창 생기게 된다. 이게 파편화(fragmentation). 이게 되면, 실제로 메모리의 공간은 충분한데도 연속적이지 않아서 메모리를 못 줄 수도 있다. 이 경우 딱히 대책이 없다면 해당 프로세스를 sleep시키는데, 이는 마치 데드락처럼 펑 될 수가 있다.

이를 해결하기 위해선, 다양한 기법이 있긴한데 학부수업에서 다루기엔 너무 많음. 대표적인 알고리즘인 buddy allocator 에 대해서만 알아보자.
참고로 리눅스에선 buddy외에도 slab allocator라는걸 쓰고, 후에 배울 paging 기법에서도 이 이야기를 할 것이다.

-buddy allocator
버디 얼로케이터도 힙이긴한데, 사이즈가 2의 지수승인 힙이다. 그리고 할당도 2의 지수승으로 한다. 할당하는 과정에서 힙을 반씩 나눠가면서 하는데, 이때 같이 나눠진 놈들을 buddy라고 한다.
왜 이러냐면, 인접함 buddy들이 할당해제되면 이들을 병합해서 큰 메모리 공간을 쉽게 확보할 수 있기 때문이다.
아쉬운 점이 있다면, 아무래도 낭비되는 공간(내부파편화)이 있다는 점.

-Free List
free list는 링크드 리스트 형태로도, bitmap형태로도 만들 수 있는데, 일단은 링크드 리스트에 대해서만 알아보자. 일단 HOLE을 어떻게 할당하느냐에 따라 정책이 달라진다.
	Best fit : Free List 중에서 가장 사이즈가 비슷한 Hole을 할당 -> 홀의 사이즈가 계속 작아짐
	First fit : Free list에서 첫 번째 Hole에 할당 -> 평균적 크기의 Hole이 생성
	Worst fit : 가장 사이즈가 다른 Hole을 할당 -> 큰 홀이 생김
best와 first가 worst보단 실험적으로 좋단게 입증되었으나, 그래도 궁극적인 해결책은 못됨. 각경우모두 50%의 메모리 낭비가 있는데, 이것을 50%의 룰이라 한다.
이는 정책적으로 해결하긴 힘든 이슈임.

-파편화의 발생 원인이 무엇인가? : 메모리 리퀘스트 사이즈와, Hole이 딱 맞지 않아서

따라서 메모리를 요청할 때, unit사이즈로만 요청하게 하면, 이런 파편화는 발생하지 않는다. 하지만 이럴경우, 해당 unit이상의 데이터에 대해선 또 파편화가 발생한다. 이에 기반해서 해결책으로 나온 것이, memory Pools이다.

-Memory pools
기본적으로 unit사이즈로만 메모리 요청을 하게한다. 대신, 다양한 사이즈를 허용한다. 버디랑 비슷하게, 2의 지수로 pool을 구성한다. 이렇게 해버리면 파편화는 발생하지 않는다.
하지만, 메모리 요청이 어떻게 올지 모르기 때문에 사이즈 비율을 배치하기 힘들다. 그래도 그나마 좀 현실적인 대안이라 많이 사용한다.
