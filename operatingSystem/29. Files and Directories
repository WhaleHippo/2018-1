-용어 정리
파일 : 디스크에 적재된 이름 있는 것들의 모음
파일 시스템 : 
File identifier :
	File Descriptor : 파일 내용에 접근하기 위해 필요한 메타데이터를 저장하는 자료구조
	Inode : 유닉스 파일 시스템에서 파일에 대한 메타데이터를 저장하는 자료구조
	Inumber : Inode의 ID
디스크 스케쥴링 : 암(arm) 스케쥴링

-내용 정리
유저는 바이트 단위로, OS는 블록 단위로 생각함.
이를 서로 변환해주어야 하는데, 이게 파일 시스템이 해야하는 일 0

-Naming : 파일 시스템이 해야하는 일 1

-File Descriptor : 네이밍을 위한 것
메타데이터로 파일 크기, 주인, 변경날짜, 권한, 위치 등
파일에 엑세스를 위해선 이런 메타데이터를 잘 저장해야한다. 이런 메타데이터가 없으면, 설령 파일이 디스크에 존재해도 접근 할 수가 없다.
근데 이녀석도 파일이라 디스크에 저장된다. 근데 그러면 디스크 엑세스를 2번해야하고, 암의 시크타임으로 인해서 접근속도가 많이 떨어지는 고로 메타데이터 엑세스가 될때는 메인메모리에 올린다.
근데 그럼 또 발생하는 문제가, 메인 메모리에서 저 메타데이터들이 바뀌어도 바로 디스크에 저장되진 않는다는 거다. 이게 바로 컴퓨터를 함부로 막 끄면 안되는 이유다.

-디렉토리 : 바이트 시퀀스로 사실상 파일과 같이 봄(유닉스에선)
디렉토리는 <"이름". Inummber> 페어로 자기가 어떤 놈들을 가지고 있는지 알려줌. 따라서 딝테로 접근, 데이터 리드는 각각 1회씩해서 총 2번의 엑세스가 필요함


-working 디렉토리 : 지금 위치한 디렉토리, 환경변수 실정 : 상대위치, 절대위치

-심볼릭 링크, 하드 링크 : 트리구조 망가뜨리기
1. 심볼릭 링크 : <이름, 절대경로>페어가 링크된 디렉토리에 추가
2. 하드 링크 : <이름, Inummber>페어가 링크된 디렉토리에 추가


-파일 시스템 : 심볼릭 네이밍을 실제 주소로 변환, 데이터 read/write
	관점 :	파일
	유저 : 파일네임 + byte offset
	커널 : Inumber + logical block number
	드라이버 : physical block number
	디바이스 : drive number + cylinder number + track number + sector number

파일 엑세스패턴 : 시퀀셜, 랜덤

링크드 파일 : 시퀀설에 적합. 렌덤은 X 그래서 요즘 안씀
인덱스드 파일 : 둘다 적합. 하지만 파일 사이즈의 제한이 있음. 왜냐면 아이노드 개수 제한이 있으니까. 이를 해결하기 위해서 파일 을 여러 블록으로 나누어 멀티플한 구조로 만든다.
	다이렉트 블록 : 아이노드가 바로 블록을
	인 다이렉트 블록 : 아이노드가 가리키는 블록이 인덱스 블록

-디스크 스케쥴 : 시크타임을 줄이자! = 실린더 넘버만 생각
엘리베이터 알고리즘! -> 엘리베이터처럼 암을 왔다갔다.
