엔지니어는 국어 능려크가 중요하다?
OS 수업에 있어서 스토리라인을 파악할 필요가 있다.
그러니 지금부터 OS의 발전과정을 알아보자. 오늘할건 페이즈 1. 참고로 MCU는 페이즈 1이 제일 재밌었던거 같기도 하고.
OS를 비롯한 모든 발전의 원동력 : 투자대비 성능을 올리자(ROI)
초창기의 OS는 휴먼오퍼레이터 : 카드덱에서 잡을 만들어서 컴퓨터 느님께 드리면 ㄲ
휴먼 오퍼레이터는 카드덱으로 미리 만들어둔 라이브러리(...)를 이용했다.
컴퓨터 시스템의 utilization( 컴퓨터가 일하는시간/컴퓨터가 켜져있는 시간)을 올리자
이시기 utillizaiont은 100%가 될 수 없었다.

-문제점
1. 사람이 하는만큼 job-to-job transition시 소모 발생
2. CPU는 되게 빠른데, 카드덱을 읽어오는 카드리더가 느려서 결국 속도가 느려진다.

-해결법
1. job을 한번에 하나만 받는게 아니라 여러개를 받아서 메모리 롬에 다 넣어둔 뒤에 한꺼번에 처리하는 것.
이런 job들의 묶음을 batch(동일한 비슷한 것들의 모임)라 한다. 그리고 이런 기법을 batch processing이라고 한다.
근데 batch processing을 하려면 휴먼오퍼레이터로는 불가능한게 있다. 그것은 한 job이 끝났을때 다음 job으로 들어갈시, 자동적으로 job을 바꿔줘야할 필요가 있다. 이 기능을 하기 위해서 Monitor가 등장한다.

2. 빠른 cpu 와 느린 카드 리더 사이에 중간속도의 디바이스를 넣음으로서 완충가능.
이런 중간디바이스로 카세트 테잎을 사용했는데 이는 카세트 테입은 일렉트로 마그네틱 장치라 일렉트로 장치인 cpu와 메카니컬 디바이스는 카드리더의 중간정도의 속도를 가진다.

1&2의 기능을 수행하는 기능을 동시에 수행하는 장비를 IBM이 만들었는데 이를 합쳐서 SPOOL 기능이라고 했다.
이를 심플 배치 모니터라고한다. 이를 통해서 초창기 휴먼오퍼레이터 보다 utilization을 올렸다.

-Monitor의 3가지 의미
1. scan한는 것
2. 메모리에 상주하면서 제어하는 것 대표적인게 PROM monotor
3. sync와 관련도니것.

-그래도 아직 해결되지 않은 문제
1. cpu는 I/O 오퍼레이션시 CPU는 정지해야했다. 왜냐하면 IO오퍼레이션도 CPU가 해야했기 때문에. 근데 당시의 IO오퍼레이션도 느렸기 때문에 이를 해결할 필요가 있었다.

`그 다음세대
카드덱보다는 빠르게 읽을 수 있는 drum/dist라는걸 쓰기 시작했다.

- 아직 해결되지 않은 문제 해결법
1. IO오퍼레이션때 CPU가 직접 관여하지 않는다. io디바이스 밑에 별도의 제어기를 설치하여 cpu가 io디바이스를 직접적으로 컨트롤 하지 않게 할 수 있도록 한다. 그럼 그런 cpu는 별도의 제어기에만 명령을 하고 다른 걸 하는게 가능.
이걸 하기위해선 2개념이 추가되는데 1. I/O controller(IO chennel)와 2. cpu에게 io가 끝났을때 그걸 말해주기 위한 인터럽트 기능이다.

인터럽트 개념의 등장으로 io오퍼레이션은 2가지로 나뉘게 된다.
1. polling io : cpu가 직접 io를 체크
2. intr-driven io : cpu가 io컨트롤러에게 명령해서 io를 하는 것

-한계점
이런 시나리오라면 어떨까. cpu가 io컨트롤러에게 명령을 내리고, 자기 연산을 계산하면 유틸라이제이션 손해가 없는데, 데이타 디펜던시가 있어서(연산도중 io결과가 필요하면) 이러지 못한다. 여기서의 io는 사람이 입력하는것 뿐만 아니라 메모리/저장장소에 접근하는것 까지 포함한다.
때문에 전자를 어싱크로너스 io, 후자를 싱크로너스 io라 한다.
어싱크로너스 io의 대표적인 예 : write 오퍼레이션
싱크로너스 io의 대표적인 예 : read 오퍼레이션
즉 이처럼, 어싱크로너스 io때보다 싱크로너스 io일 때 유틸라이제이션이 급 감소한다. run to completion이라고도 한다.
이걸 해결하기 위해 job여러개를 동시에 multiprogramed batch monitor를 만들 필요가 있었다.
(job 1이 처리되다가 인터럽트 걸리면 job2를 하게 하는 식으로)

근데 write로 싱크로너스 하게 할 필요가 있다. 예를 들어 굉장이 중요한 데이터를 disk에 저장할 경우, disk는 저장이 잘 안될때도 있었기에 엄청 중요한 데이터는 싱크로너스 write를 해서 저장의 안정성을 대폭 늘려야 했다.

-multiprogramed batch 아직 페이즈1 이다 ㅡㅡ 
동시에 수행된단게 진짜 동시에 수행되는게 아니라... job1하다가 job2하다가 job3하다가 하느식으로 왔다갔다하는것

degreeof multipromraming = 액티브(시작했지만 아직 종료되지 않은) job의 수

즉 디그리 오브 멀티프로그래밍이 옛날엔 항상 1 이였는데, 이제 1이상이 되는 것이다.
근데 이걸 하기 시작하니까 심각한 문제들이 여러개 발생하게 시작했다.

-멀티 프로그래밍의 문제점
1. 메모리 프로텍션
단적으로 말해서 포인터 에러. job2를 돌고 있는데 job1의 데이터 포인터를 가리키거나해서 엉킹

2. 리로케이션
이거도 따지고 보면 포인터 에러. 예산에는 job의 시작주소가 1000번지로 동일 했는데, 이제는 메몰의 시작주소가 어떤지 몰랐다는게 문제.

3. 싱크로나이제이션
본 문제점들의 난이도의 최종보스. job이 여러게 왔다갔다 수행되다보면, 발생되는 에러. 교수님은 형제가 서울과 부산에서 동시에 atm에서 돈을 뽑을 경우 발생하는 문제를 말해주심.

-1,2해결법
1. job의 사이즈를 계산한 후에, job의 사이즈를 이탈하는 포인터를 가르킬 경우, ㅗ를 날리는 것. 그리고 이런 job의 범위를 가지는것을 bound 레지스터라고 한다.
2. 프로그램이 모두 0번지에서 시작한다고 생각하고 짜되, 실제로 주소에 진입할때는 메모리의 시작값을 더해주는것. 즉 상대주소를 절대주소로 변환. 이때 그 job의 시작주소를 베이스레지스터라고한다. 이때 프로그래밍할때 시작주소가 0이라 생각하고 짠걸 로지컬 어드레스, 실제 주소를 피지컬 어드레스라고 한다.

정리 : cpu -> 바운드 레지스터 확인 -> 베이스 레지스터를 더해서 절대주소로 변환

이걸 MMU라고 하고 새로운 디바이스로 만들었다.

-왜 MMU는 하드웨어로 구현해야하는가?
MMU를 소프트웨어적으로 구현하면, MMU를 수행하기 위한 인스트럭션(job비스무리한거로 컴퓨터 명령어의 최소단위)가 되어야하는데, 이는 cpu의 프로그램카운터 레지스터가 job메모리를 가리키면, 그거에 해당되는 메모리가 cpu의 인스트럭션 레지스터가 그걸 받아서(fetch), 디코드하고, 엑스큐선하는데 MMU는 이중 fetch와 엑스큐선 단계에서 사용된다. 이걸 소프트웨어적으로 구현하면 성능이 2배 가까이 내려간다.
또한, 이걸 소프트웨어적으로 구현하면 MMU 역시 job의 일종이 되므로, 재귀적인 문제가 발생한다.

-OS입장에서  MMU는 Transparent(블랙박스 인가 아닌가)하는가? 즉 OS입장에서 MMU에게 무언가를 하지 않아도 되는가?
OS는 MMU에게도 관여해야한다. 즉 transparent하지 않다. OS는 job이 바뀔때마다 bound, base레지스터의 값을 지속적으로 바꾸어 주어야한다.

-퀴즈
하드웨어 중에서 programmable한게 있고 아닌게 있다. programmable한 하드웨어는 다양한 용도로 바꿀 수 있어야한다. 그렇기때문에 레지스터가 꼭있어야한다. MMU도 programmable한거다. 왜냐하면 레지스터가 있고 레지스터값에 따라서 제어하는 job이 달라지니까.

-최종보스 3해결법
안했...나?

이제 다음시간부터는 카드덱이 아니라 진짜로 컴퓨터로 코딩하는 시대가 열린다. 왜 그게 가능해졌는지는 다음시간에 계에소옥!
