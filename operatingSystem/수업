5월 24일
디멘드 페이징의 최종 목표 : 쓰레슁을 줄이자. 블리츠크랭크를 애용하자.
디멘드 페이징의 주된 이슈
1. 어떤 페이지를 불러올 것인가? : page selection
	디멘드 페이징에선 디폴트가 스왑상태에 있다고 생각한다.
	이러면 속도가 무지 느리니 예측해서 몇가지 페이지를 가져온다.
		로케일리티를 감얀해서 한 페이지가 읽혀지면 주변 페이지를 읽는다.
	request paging
2. 

세컨드 찬스 : 바로 스왑 디바이스로 쫒아내기 전에 한번더 부활할 기회를 주는 것.
워킹셋 : 자주 사용되는 페이지들의 그룹

페이지를 관리하는 법
0. 옵티멀 : 구현 불가
1. 렌덤 -> 개판
2. FIFO : 먼저 피지컬에 온놈을 스왑디바이스로 쫒아내기 -> 부팅 프로세스가 웁니다.
3. LRU : 제일 오래전에 사용되는 놈을 스왑 디바이스로 쫒아내는것 -> 효과적임. 왜냐면 로케일리티 땜시 한동안 접근 안한거면 그 주변도 안쓰인다고 생각 할 수 있으므로.

LRU를 어떻게 구현해야할까? 자료구조 + 알고리즘
자료구조에는 뭐가 들어가야 할까?
페이지가 언제 읽혔는지 -> 시간!
근데 시간을 측정하는게 만만치가 않음 CPU가 엄청 빠른 속도로 이동하니까.
암튼 시간을 측정해서 이걸바탕으로 sorted list를 구성. 가장 안 읽힌 놈이 맨 앞에 오도록.
근데 이건 소프트웨어적으로 구현하면 매우 느려서, HW가 제공해줘야한다. 근데 선술했듯이 CPU가 매우 빨라서, 타이머 TICK이 쉽게 오버플로우가 나 버린다.
결국은 LRU조차도 구현이 힘들다. 그래서 이걸 또 근사한다.

레이지의 레퍼런ㅅ bit를 이용. 레퍼런스 bit가 0이면 페이지가 들어온 이후로 한번도 엑세스가 안되었다, 1이면 들어온 이후로 1회는 엑세스가 되었다는 것.
이렇게 해서 레퍼런스 bit가 0인 놈들을 빼내는 식으로 함.
근데 이렇게 하면 너무 단순하니까,
주기적으로 0으로 리셋하고(OS가) 또 주기적으로 0인 놈들을 빼내는 식으로 하면 된다.
이제 자구는 되었고, 알고리즘 쪽을 자세히보자.

클락 알고리즘 : n개의 페이지를 서클형태로 연결하고, 하나의 포인터가 빙글빙글 돌아가면서 가리키기 때문에 클락 알고리즘이라고 한다.
1. 포인터의 레퍼런스 비트가 0이면 해당 페이지을 빼낸다.
2. 포인터의 레퍼런스 비트가 1이면 0으로 바꾸고, 다음페이지로 넘어간다.

클락의 포인터가 적당한 속도로 도는게 중요하다. 만약 너무 빠르게 돌면 이건 마치 FIFO처럼 된다.

enhanced clock 알고리즘 : 위의 클락 알고리즘의 개선판
레퍼런스 비트말고 dirt비트도 본다.
우선순위	레퍼런스	dirty
1		0		0
2		0		1
3		1		0
4		1		1

우선순위가 높은순으로(숫자가 작을 수록) 빼낸다

근데 클락 이나 인핸스 클락이나 레퍼런스 비트를 아키텍처가 제공하지 않으면 무용지물이 되어버린다. 이 경우에는 시간을 (간접적으로나마)측정할 방법이 없어서 LRU의 구현이 불가능하다. 이때는 부득이하게나마 FIFO를 쓴다;

FIFO의 개선을 어떻게 해결해야할까? -> 한번 더 사용되면 살린다.
멀티레벨 큐 같은 느낌으로,
첫번재 큐에서 강등되면 두번째 큐로, 두번째 큐에서도 강등되면 나가리, 언제든 엑세스되면 첫번째 큐의 마지막 요소로 push
첫번째 큐에서 두번째로 강등되는 경우는 페이지 폴트로 인해서 큐가 ++ 되는 경우,
두번째 큐에서 강등되는 경우는 MMU가 추가적인 인터럽트를 걸어주어야 한다. 벨리드 비트를 0으로 바꾸면 그걸 세컨드 찬스로 사용.
이때, 두 큐의 사이즈는 OS에 의해서 튜닝된다.






페이지 프레임을 할당하는 방식 3가지
1. 글로벌 할당 :  프로세스의 구별을 안하고 페이지를 가져올 수 있음
+ 관리는 간편
- 어떤 놈이 독점
2. Per 프로세스 할당 : 프로세스에게 가져오는 페이지 개수를 제약
3. Per job 할당 : 





--------------------------
working set : 어떤 페이지가 사용되면, 그외의 다른 어떤 페이지들이 함께 사용된다는 것을 OS 가 스스로 알아서 올려주면 좋겠다. 그런 개념에서 출발한게 바로 working set. 정확한 정의는 "어떤 시점에서 특정 프로세스가 access 하는 페이지들의 집합. 그 프로세스의 그 시점의 locality" 그때의 시간간격을 time window라고 한다.

그런 working set이 효율적인가? 꼭 그렇진 않다. time window을 잘 잡아야 한다. 또한 워킹셋을 실제로 잡기 힘들다.

암튼 워킹셋이 도입되면, 프로세스 스케쥴링때도 같이 사용가능하고. 기본적으로 워킹셋들끼린 같이 돌아다닌다.

암튼 워킹셋은 구현해야한다. 어떻게?
근사적인 방법 : 페이지를 일단 두고 페이지 폴트가 몇번 나나 본다. 그래서 페이지 폴트가 규정치 이상으로 많이 나면 페이지를 추가로 할당한다. 이렇게 했을때 페이지 폴트가 규정치 미만으로 내려가면, 그때그게 워킹셋이라 추정할 수 있다. 이때 이건 Resident Set이라고 한다.

이렇게 워킹셋이 완성되면, 프로세스가 나갈땐 워킹셋도 스압아웃하고, 프로세스가 가디 슬어올땐 워킹셋도 메인메모리로 들어오게 물론 이건 메인 메모리가 모자라서 스왑디바이스를 해야할 때이다. 메인 메모리가 충분하면 스왑아웃이든 스압인 이든 할 필요 없다.



-Out of memory killer : OOM killer
위에서 논의된 이야기는 스왑디바이스가 충분하다고 가정했다. 근데 스왑공간도 왕창 줄어들면? 그땐 도리가 읎다. 프로세스를 킬해서 페이지를 free하게 해주는 수밖에. 그걸 휴리스틱하게 잘 없애준다.

이걸로 디멘드 페이징은 끝! 메모리와 관련하여 조금만더 이야기하자

메모리 관리 트랜드
1. 반도체기술 향상으로 메모리사이즈와 가치가 확 줄어듬.
2. 64bit머신으로 이행하면서 페이지테이블이 무진장커져버림. 그리고 어드레스 스페이스 상에서 빈공간의 활용?
3. 시스템간의 복잡도.
