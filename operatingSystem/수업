4월 10일

왜 fork를/exec을 하는걸까? 이건 되게 비상식적이다. 근데 한편으론 이걸 계속 써온 방식이기도 하다.
일단 이게 왜 비상식적일까? : 오버헤드의 발생. 낭비가 있다. 불필요한 메모리 복사가 있어야 한다. 실제로 윈도우는 이런 부모 자식 복사가 아니라 처음부터 만든다.
그럼에도 불구하고 이런 방식을 사용하는 이유는... 프로그램의 시작 주소 때문이다. 하나의 컴퓨터에는 프로세스 수만큼의 로직 주소가 있고, 실제 물리적인 주소는 하나이다. 때문에 프로그램 이밪ㅇ에서는 지의 시작 주소를 확실하게 파악해둘 필요가 있는데, 이를 해결하기 위해선 프로세스끼리 통신을 할 필요가 있었다. 근데 그 시절에 그딴 기술이 있을리가 없잖아. 지금처럼 파일같은 거도 못하고. 그러니까 걍 fork를 했다.


그래도 풀리지 않는 의문점 : 그래 그렇다 치자. 근데 그러면 부모껀 다 복사할 필요가 없지 않는가?
그래서 해결법을 찾음. 바로 shadow카피를 하는거임. 쉐도우 카피는 각 세그먼트를 가리키는 포인터만 똑같이 하는거다. 그러면 포인터만 복사하면 되니까 몹시 편해짐. 근데 이러면 오염의 문제가 있게되는데... 이걸 해결하기위해서 write오퍼레이션이 필요할때만 실제로 카피를 수행하는 거다. 이걸 COW(copy on write)라고 한다. 이대 write오퍼레이션때 인터럽트를 똭 갈겨주면 끝난다.



프로세스 끝
-----
멀티스레딩

지금까지한건 유닛으로서 프로세스



4월 12일
수업직전 리뷰
멀티스레딩 하는 이유 1 : 자원을 공유하는거
2.
스레드를 어떻게 구현할 것인가? -> 스택을 이용한다.


오늘 수업 내용
쓰레드는 함수로 구성된다. 가장 처음 시작되는 스레드는 main함수로 구성되는거 처럼.
pthread_create(함수포인터) 같은식으로 해당 스레드를 만든다.
pthread_exit() : 그 함수를 박살
pthread_yield() : cpu를 양도
pthread_join() : 스레드의 종료할때까지 기다리는 기능. 보통 동기화를 목적으로 함.

실제 샘플코드
pthread_t의 배열이 쓰레드 컨트롤 블락 역할을 한다.
여기까진 하이(?)레벨의 이야기. 이제 로우레벨의 OS쪽으로 들어가자. 다시말해서 저 pthread_함수 뭉텅이들이 어떻게 짜여졌는지 이야기하자는 거다.

이 방법은 2가지가 있는데
1. 라이브러리 함수로 만들기 : 유저레벨 쓰레드 인플리멘테이션
2. 시스템 콜로 만들기 : 커널레벨 쓰레드 인플리멘테이션
