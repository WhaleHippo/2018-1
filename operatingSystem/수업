4월 10일

왜 fork를/exec을 하는걸까? 이건 되게 비상식적이다. 근데 한편으론 이걸 계속 써온 방식이기도 하다.
일단 이게 왜 비상식적일까? : 오버헤드의 발생. 낭비가 있다. 불필요한 메모리 복사가 있어야 한다. 실제로 윈도우는 이런 부모 자식 복사가 아니라 처음부터 만든다.
그럼에도 불구하고 이런 방식을 사용하는 이유는... 프로그램의 시작 주소 때문이다. 하나의 컴퓨터에는 프로세스 수만큼의 로직 주소가 있고, 실제 물리적인 주소는 하나이다. 때문에 프로그램 이밪ㅇ에서는 지의 시작 주소를 확실하게 파악해둘 필요가 있는데, 이를 해결하기 위해선 프로세스끼리 통신을 할 필요가 있었다. 근데 그 시절에 그딴 기술이 있을리가 없잖아. 지금처럼 파일같은 거도 못하고. 그러니까 걍 fork를 했다.


그래도 풀리지 않는 의문점 : 그래 그렇다 치자. 근데 그러면 부모껀 다 복사할 필요가 없지 않는가?
그래서 해결법을 찾음. 바로 shadow카피를 하는거임. 쉐도우 카피는 각 세그먼트를 가리키는 포인터만 똑같이 하는거다. 그러면 포인터만 복사하면 되니까 몹시 편해짐. 근데 이러면 오염의 문제가 있게되는데... 이걸 해결하기위해서 write오퍼레이션이 필요할때만 실제로 카피를 수행하는 거다. 이걸 COW(copy on write)라고 한다. 이대 write오퍼레이션때 인터럽트를 똭 갈겨주면 끝난다.



프로세스 끝
-----
멀티스레딩

지금까지한건 유닛으로서 프로세스
