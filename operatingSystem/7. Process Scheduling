-단어 정리

스케쥴링 : 각프로세스들이 fair하게 CPU를 공유할 수 있도록, 다음에 수행할 프로세스를 선택하는 작업

스케쥴러가 만족시켜야하는 것  fair + CPU protection
	fair하다? : 어디까지나 상대적. 보통은 1/n이지만, 중요한 시스템이 있다면 그쪽에 우선적으로
	protection : 프로세스의 교환에 의해서 기존의 프로세스가 망하는 일이 없도록

dispatcher : OS의 가장 깊은 곳에서 무한루프(주어진 프로세스를 어느정도 돌리고, 그 프로세스의 상태를 모두 안전한 상태로 보관, 정책에 의해서 선택된 프로세스를 수행)를 돌리는 놈. 스케쥴링과 context switching을 하는 주체이다.

Non-preemptive 스케쥴링 : 프로세스가 자발적으로 블락되어 CPU를 내놓음(IO인터럽트 등)
preemptive 스케쥴링 : 프로세스가 스케쥴러에 의해서 강제적으로 CPU를 내놓음




-내용 정리
-policy vs mechansim
핸들을 돌리는 것 : 메카니즘
어느 고속도로로 갈지 정하는 것  : 정책

-스케쥴러의 2 단계
	1. 어느 프로세스로 넘길 것인지 선택하는 기준 : 스케줄링 policy : 
	2. CPU를 한 프로세스에서 다른 프로세스로 넘기는 구체적인 방법 : mechanism : 디스패처
일단 2.에 해당되는 거부터 먼저 배우자. 1.은 나중에

-Dispatcher
디스패처는 프로세스를 어느정도 돌리고, 그 프로세스의 state를 모두 안전한 상태로 보관하고, 정책에 의해서 선택된 프로세스의 상태를 load하고, 선택된 프로세스를 또 어느정도 돌리다가...를 무한 반복하는 녀석이다.
근데 뭔가 이상한게, 위의 내용대로라면 디스패처를 전문적으로 돌리는 별도의 cpu가 있어야 할거 같다. 근데 실제론 그런건 없다. 그 이유는? 그 이유는 디스패처가 하드웨어적인 인터럽트로 유저모드와 커널모드 왔다갔다하면서, 커널모드에서 디스패처를 실행하기 때문이다. 이런 모드 체인지로 인하여 디스패처를 포함한 os는 단일 프로세서 환경에서도 동작 할 수 있는 것이다.

-tip : 몇번인가 말하지만, 모드 체인지를 위해서는 인터럽트가 필요하다. 마이크로 아키텍처를 설계할때부터 인터럽트가 걸리면 걍 모드가 커널모드가 되게 했다. 
-tip2 : OS는 커널모드에서 실행되는 함수(시스템 콜, ISR)들의 모임이기에, 되게 "수동적"이다.


-디스패처의 수행은 저런 시스템 콜의 일종인 디스패처함수가 수행된단 것을 말한다.
이런 디스패처의 호출에는 2종가 있다.
	1. Non-preemptive 비선점 스케줄링 : 프로세스가 스스로 cpu를 양보
		사례 : 동기적 I/O과정에서의 블락
		구현방법 : 소프트웨어 인터럽트(트랩)을 통해서. 스스로 블락될거 같으면 디스패처를 호출, 시스템 콜
	2. preemptive 선점 스케줄링 : 프로세스가 OS에게 CPU를 빼앗음
		사례 : OS의 time shareing과정
		구현방법 : 타이머를 이용, 때문에 하드웨어 인터럽트에 의해서 수행됨
		
-모드 체인지 과정의 타임라인 : 프로세스가 스토리지를 읽고자 할때
	1. 프로세스의 read() 시스템 콜 호출
	2. read()에 의해서 인터럽트(트랩)발생
	3. 모드 체인지(유저->커널)
	4. 커널 모드에서 커널 모드 함수인 sys_read()가 수행
	5. 모드 체인지(커널->유저)
	
	이런 과정에서, 이때 수행 중인 프로세스는 커널이 아니라, read()를 호출한 프로세스다. 전 수업에서 말한거처럼, 프로세스는 수행의 주체(context)이다.
	또한 프로세스의 현재 상태는 그 프로세스의 스택을 통해서 trace한다. 프로세스는 스테이트와 익스큐션스트림(쓰레드 오브 칸트롤)이 있는데, 스택을 검사하면 디버깅 가능하다. 때문에 스택은 런타임 컨텍스트라고도 한다.-> 프로젝트에 사용
	시스템 콜이 진행되어 커널함수를 호출할 경우, 기본적으로 사용하는 유저모드 스택이 아니라, 커널 모드 스택을 사용한다. 때문에 프로세스 진행중 런타임 컨텍스트는 변화 할 수 있어도, 프로세스 ID는 계속 똑같이 유지된다.
