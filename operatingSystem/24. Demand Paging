-용어정리
Demand Paging : 수요 페이징 : 메모리 관리메커니즘(MMU메커니즘)을 이용해서 여러프로세스가 시스템의 메모리를 효율적으로 공유하게 하는 기술
address mapping mechanism : MMU와 페이징이 제공하는 매커니즘. 그냥 테이블에 쫙 써두는거
Principle of Locality : 프로그램이 가장 최근에 접근했던 데이터를 다시 접근하거나, 최근에 참조했던 데이터 근처의 주소를 참조하는 경향이 있음. 루프 때문에. 이거랑 관련된 말이 90/10 rule
90/10rule : 코드의 1할이 전체 수행시간의 9할을 차지함. 루프땜시
버추얼 어드레스 : 논리 얻레스의 확장판. 스왑공간을 포함해서 피지컬 메모리 이상의 사이즈를 가지는 공간.
residnce bit : 대상 페이지가 피지컬 메모리에 있는지 Swap device에 있는지 표시하는 페이지 테이블의 플래그 보통 vaild bit를 이용한다. 1이면 피지컬, 0이면 무효거나 스왑공간에 존재.
Page Fault : 필요한 페이지가 피지컬 메모리에 없는데 접근하려고 함으로써 발생하는 트랩

-내용정리

-프로세스의 모든 데이터는 메모리에 로드되어야 하는가?
그렇진 않다. 프로그램은 Locality를 가지고 있기 때문에. 그렇기에 프로세스가 필요하는 모든 공간을 피지컬 메모리에 로드할 필요가 없다. 그렇다면 피지컬 메모리에 로드될 필요가 없는 페이지들은? 스왑 디바이스에 둔다.

-스왑 디바이스와 파일 시스템
두개다 보조 저장장치에 위치하는 것은 동일하다. 하지만 차이가 존재한다.
파일에 엑세스 하는 과정에서 OS가 왕창 개입한다.
스왑디바이스에 도달하는데에는 다이렉트 엑세스가 가능하게 한다. 그래서 파일에 비해 빠른 접근이 가능하다.

스왑인 : 스왑 -> 피지컬 메모리 : 안쓰는 메모리가 생각해서 스왑에 두었는데, 읽어야 할 경우

스왑아웃 : 피지컬 메모리 -> 스왑 : 안쓰는 메모리를 두기, 새로운 페이지를 만들려는데 피지컬 메모리의 여분이 없을경우, 그리고 바꾸려는 페이지가 dirty일 경우. 바꾸려는 페이지가 dirty하지 않으면, 스왑 인 한 이후로 변경사항이 없기 때문. 그래서 스왑공간에 그대로 복사본이 있을테니 굳이 이동시킬 필요 없다.

이런 스왑은 분명 용이하긴 하나, 빈번하게 발생하면 전체적으로 프로그램이 느려진다. Demand paging policy의 목적은, "피지컬 메모리와 스왑 디바이스 사이의 데이터 전송을 최소한 하는 것이다."

-이상적인 Demand paging
이상적인 Demand paging은 프로세스의 어떤 요소들이 필요한지 확인해서 그 페이지들만 피지컬 메모리에 올리고, 나머지는 스왑영역에 두는 것(IO가 idle할때 DMA로)이다. 하지만 이건 불가능하다. 그렇다면, 최소한 어떻게 비스무리하게라도 할 수 있는지 알아보자.




-Page Fault Handling
Demand paging을 하려면 몇가지 기술적 이슈들을 해결해야한다. 그중 가장 중요한게 Page Fault이다.
페이지 폴트 발생시 : 현재 콘텍스트 정지 -> 페이지 가져오기(DMA) -> 그동안 현재 프로세스는 sleep

문제 : 기존의 인터럽트와는 달리 최소 수행시 기존에 있던 인스트럭션을 수행 할 수 없다.
해결법 : 마이크로코드를 통해서 역연산을 제공. 그래서 다시 되돌아가는게 가능하도록. 다시 말해, 역연산이 불가능한 인스트럭션은 페이지 폴트 핸들링이 불가능함(?)

이제 디멘드 페이징의 이슈들을 보자.
1. 페이지 선택 정책 : 어떤 페이지를 불러올 것인가?
2. 페이지 교체 정책 : 어떤 페이지를 내보낼 것인가?
3. 페이지 교체 스타일 : 모든 페이지를 대상으로 할것인가, 아님 특정 페이지만 대상인가?
4. 페이지 할당 정책 : 페이지를 프로세스에게 할당할 때 정적? 동적?
