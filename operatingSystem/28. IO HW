-용어 정리
캐릭터 디바이스 테이블 : 캐릭터 디바이스들의 드라이버의 위치. 타입(메이저 넘버)만큼의 인덱스가 있고, 메이너넘버로 접근

twolevel interrupt handling : 바텀 하프를 이용

-내용 정리
-IO디바이스구조
내부에 렞스터와 콘트롤러, 로직이 있고, 이걸 Bus interface로 버스 연결함
어드레스 버스, data버스, 컨트롤 버스

-IO 디바이스 종류
1. 블록
2. 캐릭터
3. 네트워크

-IO 디바이스 데이터의 이동
IO디바이스가 데이터 전달(인터럽트) -> 드라이버(이벤트) -> 프로그램(메세지)

-디바이스 예와 드라이버
1. 마우스
드라이버가 할일
	인터럽트 핸들러
	데이터 가져오기
	이벤트큐를 가지고 인터럽트를 변환한다.

2. 터미널 : 인풋 + 아웃풋 디바이스
키보드 : 키보드 데이터와 readybit으로 들어감
드라이버
ready bit이 1이면 키보드 데이터를 읽고 ready bit을 다시 0으로 해줌
이때 읽은 데이터를 line buffer에 넣어준다. 그리고 end of line 데이터가 오면 그걸 운영체제에게 전달
디스플레이 : 디스플레이 데이터도 ready bit과 디스플레이 데이터로.




3. 디스크 : 블록 디바이스
디스크는 원판과 헤드가 있다. 헤드가 read/write를 한다.
디스크는 하나의 회전축에 여러개의 자화 원판이 있다. 헤드는 각 디스크 마다 2개. 즉 한면에 1개씩 있다.
트랙 : 동심원들
실린더 : 각면단다의 동심원들의 모임
섹터 : 피자 썰듯 트랙을 썬것

실린더 단위로 읽는게 빠르다. 왜냐면 헤드들은 같이 움직이니까.

	디스크의 동작
	읽기명령 : 섹터의 주소(실린더#, 트랙#, 섹터#)를 준다. -> 암이 이동 -> 헤드가 이동
	seek time : 헤드를 가진 암를 목표지점까지 이동하는데 걸리는 시간
	
4. 플래시 : 스마트폰 등에서 사용되는 블록 디바이스
	엑세스패턴 : 램과 다름


-디바이스 드라이버 : 디바이스를 잘 활용하게 해주는 것, 데이터 접근, 디아비스 제어를 위한 함수 제공
디바이스 제어를 위한 함수의 예 open : 초기화, close : 반대, read/write, ioctl : 컨트롤
결국은 데이터레지스터나 컨트롤레지스터를 제어하는 것

캐리터 디바이스의 경우 : 주로 시퀀셜 엑세스
블락 디바이스의 경우 : 보통 랜덤 액세스, 블록 버퍼 캐시

유닉스의 경우는 /dev 폴더에 심볼릭한 이름으로 관리

-파일 시스템의 역할
	1. 디스크에 있는 데이터를 읽거나 쓰기 기능 제공
	2. 시스템에 존재하는 리소스에게 name space를 제공 -> for 유저 프렌들리 /dev : 디바이스 파일 -> 테이블로 맵핑
	파일 : data(real data + meta data)
		real data : 내가 관심 잇는 데이터
		meta data : file의 특성을 표현하는 부가적인 데이터(생성, 수정, 권한)

-디바이스 파일의 내용
	meta data : 디바이스의 특징(block, 캐릭터), 메이저(어떤 타입의 디바이스인가 tty)/마이너 넘버(어떤 기계인가 001). 예를들어 컴퓨터에 아두이노 2개 연결하면 ttyACM0, ttyACM1
	
	
-캐릭터 디바이스 드라이버
	캐릭터 디바이스 테이블에 인덱스 : 메이저 넘버
	메이저 넘버로 캐릭터 디바이스 테이블에서 드라이버 포인터를 얻어옴. 그 포인터 주소로 가보면, 각종 드라이버 함수들의 펑션 포인터를 얻을 수 있음. 디바이스의 이름과 기타 등등 속성도 알 수 있음.
	
-블록 디바이스 드라이버 : 큰 차이 없음
	캐릭터 디바이스 테이블의 인덱스 : 메이저 넘버
	캐릭터 디바이스 테이블로 추가되는것 : 블록 버퍼 캐시
	블록 디바이스를 캐릭터 디바이스처럼 엑세스하고 싶으면 유닉스에선 기능을 제공함


-리눅스의 인터럽트 핸들링
동일한 IRQ가 여러개가 오면, 하나만 수행되어야 한다. 이를 위해서 인터럽트 마스킹을 하는데 그 시간은 짧을 수록 좋다. 이를 위해, 리눅스 계열에선 two level intterupt 핸들링을 한다.
인터럽트 발생 -> OS에 크리티컬한 이슈만 수행(이 과정에서 인터럽트 디스에이블) -> 나머지는 커널레벨 쓰레드에서 돌개함(바텀하프, 나중에 시간날때 돔)
또한 바텀하프는 추가적인 최적화로서 여러개의 인터럽트가 보낸 시그널에 대응하도록 할 수 있다.

-

-드라이버 제공함수의 특징
1. open : 마이너 넘버를 찾아옴. 그래서 적절하게 이니셜라이즈, open한 프로세스 수를 카운트, 인터럽트 핸들러를 등록
2. close : open의 반대
3. read/write : 디바이스의 데이터 레지스터(블록캐시)에서 값을 읽거나 씀
		polling IO의 경우 : 주기적으로 os가 체크. Ready flag가 1일때만 가져옴
		인터럽트 드리븐 IO : 디바이스가 시그널을 보냄
		
		non blocking IO : Ready flag가 0이면 걍 무시하고 안함
		blocking IO : Ready flag가 0이면 1이 될 때까지 기다림
