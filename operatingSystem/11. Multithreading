-단어 정리
멀티스레딩의 목적 : concurency는 증가시키고, Execution Unit(프로세스)을 생성하거나 수행시키는데 드는 부담은 줄임
Architecture : 시스템 전체를 설계하는데 사용하는 디자인 패턴
TCB(Thread Control Block) : Thread의 구현을 위해 필요한 자료구조
Thread ID : 프로세스가 스레드에 부여하는 ID
Task : 디자인 타임에서의 프로세스를 Task라고 한다. 멀티스레딩이 나오기 전까진.
POSIX포터블OS시스템인터페이스 : 다양한 유닉스 계열 운영체제의 API표준화를 위해 IEEE가 정의한 인터페이스
	pthread : 저 POSIX의 API들중 스레드와 관련된 것


-내용 정리

-멀티스레딩의 등장
프로세스가 하나 생성되려면 context도 생성되어야하고, 논리 메모리를 물리 메모리를 변화시키기위한 mapping도 되어야 하기에, 프로세스 수가 늘어나면 시스템 전체의 효율도 급감한다. 이를 해소하기 위해서 멀티스레딩이 등장했다.

프로세스 : context + Thread of control(excution stream)
context는 프로세스에게 부여된 자원이고, Thread of control는 수행주체이다. 헌데 프로세스 안에 1개의 Thread of control만 있을 필요는 없다. 그래서, 하나의 프로세스에 여러개의 스레드를 넣어보자!하는 거였다. 즉 멀티스레딩은 프로세스의 자원을 공유하는 여러 스레드를 쓰는거다.

일단 스레드는 프로세스의 하위이므로, 스레드 역시 state(레디, 러닝, 웨이트 등)의 상태를 가지고, context switching이 일어난다.

-그럼, 스레드는 어떻게 구현할 것인가? 
스레드는 excution stream이고, 이는 시퀀스에 따라 실행되는 함수들이다. 따라서 스레드는 스택형태로 구현되어야 하고, 이는 스레드 하나당 스택이 1개씩있어야한다는 뜻이다(그래서 프로세스는 스택이 여러개이다.), 그리고 이런 스레드들을 구분하기 위한 ID와 TCB도 있어야 한다. 나아가, 이 스레드의 실질적인 동작을 담당한 excution stream, 즉 함수가 있어야한다.

-멀티스레드의 등장으로 인해서 Task와 프로세스가 1:1로 대응되지 않게 되었다.


-멀티스레딩를 구현하는데에는 크게 3가지 방법이 있다.
1. user level의 라이브러리로 구현 : 과학 연산에는 인터럽트가 딱히 없으니 이걸로 한다.
	장점 : OS를 건들필요가 없다. 즉 코스트가 비교적 적다. 오버헤드가 적다.(인터럽트를 발생시키지 않으니)
	단점 : OS는 지금 돌아가는게 뭔지 모른다.
		1. 만약 여러 개의 스레드 중 하나가 시스템콜을 할 경우, 다른 스레드도 모두 블락되는 문제가 발생한다.
		2. 인터럽트로 인해서 블락이 끝났다고 해도, OS는 인터럽트의 결과를 어떤 스레드에 주어야 할 지 모른다. 따라서 만약 이벤트가 발생하고, 그 이벤트가 OS의 시스템콜과 관련되어서 발생한 인터럽트라면, 프로세스는 OS에 그 인터럽트를 받았을때 그 인터럽트의 발생 주체인 스레드가 누구인지 파악하는 과정이 추가로 필요해진다.
		이런 문제로, 유저레벨 스레드 구현방식은 non-premtive즉 코루틴만 가능하다.
2. kernel의 system call로 구현 : 커널레벨 쓰레드 인플리멘테이션 : 현재는 대부분 커널 방식으로 구현한다.
3. 두개를 혼합

-POSIX pthread API
결과적으로, 쓰레드는 함수로 구성된다. 가장 처음 시작되는 스레드는 main함수 인 것처럼.
1. pthread_create(함수포인터) : 함수포인터를 통해서 스레드를 만든다.
2. pthread_exit() : 스레드가 스스로 종료시킨다.
3. pthread_join(스레드포인터) : 이건 wait와 비슷한데, 스레드포인터의 스레드가 종료될때까지, 대기탄다.
4. pthread_yield() : 비선점 스케쥴링처럼 스스로가 CPU점유를 포기한다.


