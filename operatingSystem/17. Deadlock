단어 정리
deadlock
deadlock 발생필요조건
deadlock 대처 : 예방, 회피 + 무시
은행원알고리즘

Resource allocation graph : 요청간선, 할당간서, 예약간선(점선)



내용정리
-deadlock
여려프로세스들이 멀티프로그램으로 실행될 때, 프로세스들이 요청한 자원을 서로 다른 프로세스가 점유대기하고 있어 무한대기상태에 있는 것
이런 deadlock에는 2가지 사촌이 있다.
	0. deadlock : 자원을 점유한체로 대기wait. CPU 파워 등 자원 낭비는 없음.
	1. livelock : 자원을 소모하지만, 유의미한 일은 안함. CPU파워가 낭비됨.
	2. indefinite postponement : 프로세스 하나에서 발생. 절대 일어날수 없는 이벤트를 대기. 예를들어 이벤트를 발생하기로 한 HW, SW등이 파괴되는 등.

-deadlock 발생 필요조건
	1. 상호배제 : 점유가 되면 공유가 안됨
	2. 점유대기 : 자원요청시 점유중인 자원은 계속 점유하고, 자원을 받을때 까지 대기
	3. 비선점 : 프로세스가 자원을 가지고 있는 도중에 포기하고 주는게 불가능함
	4. 순환 : 순환

-deadlock 대처
	1. 예방 : 필요조건들이 만족 할 수없게 하는것.
	2. 회피 : 프로세스로 하여금 정보를 제공하게 해서 데드락을 회피 은행원 알고리즘 등
	3. 감지 : 발생하게 내버려두고, 발생하면 감지해서 해제하는 것.


-예방
	1. 처음부터 다 받게 한다(hold and wait방지).
	2. 프로세스와 리소스에 우선순위 번호를 매겨, 그 순서대로 요청하도록 한다(순환대기 방지).
이처럼 요청 프로코톨 자체에 제약을 둔다. 런타임시 오버해드는 적으나, 시스템 이용률이 급감한다.

-회피 : 은행원 알고리즘
safe state : safe sequence가 존재.
unsafe state : safesequence가 존재하지 않음.
은행원 알고리즘은, 최대한 safe state에 머물게 하게하는게 목표이다.
	1. 프로세스들의 현재 사용량, 최대 요구량과 지금 할당해줄수 있는 자원량을 표시
	2. 1.의 상태가 안전한 상태인지 확인
		각 프로세스들이 최대로 요청을 했을때, deadlock이 발생하지 않는다.
	3. 요청이 오면, 그 요청을 들어 주었을때 안전한지 확인하고, 안전하면 승락
	불안전하면, 승락하지 않고 대기
Work array : 어떤 자원의 개수를 저장하고 있는 어레이
finish array : 프로세스가 종료되었는지 확인 하는 어레이

이런 방식의 최대 문제점은 runtime시 안전 여부를 체크하느라 엄청나게 cpu power을 낭비해야한단것. 그래서 보통은 감지 및 복구를 한다.

-감지 및 복원
1. 각 자원이 한개씩일 경우 : 자원 할당 그래프에서 사이클이 있으면 감지
