용어정리
paging
page
frame
page table
PTBR : 페이지 테이블 베이스 레지스터
외부파편화,
내부파편화

내용정리
-pageing의 도입배경
세그멘테이션으로도 파편화 문제는 해소할 수 없었다. 이를 해소하기 위해서 고안/도입된 방법이 페이징
파편화가 발생하는 이유는
	1. 프로세스가 요구하는 메모리사이즈가 항상 다르기 때문이다.
	2. 요구되는 메모리가 실제 메모리상에서 연속적이여야 하기 때문이다.
이러한 이유에 착안해서, 기본적으론 유닛사이즈로 할당하되, 유닛사이즈 이상으로 할당할 필요가 있을시, 연속적으로 할당하지 말고, 존재하는 유닛사이즈를 모아서 할당하는것. 이러한 아이디어에서 출발하는 것이 페이징이다.

paging은 메모리할당을 page라는 유닛사이즈로 하는 것.


-페이지와 프레임 : paging의 핵심 개념
	page : Logical Address Space를 일정한 크기로 나눈 Memory Block
	frame : physical Addreees Space를 일정한 크기로 나눈 Memory Block 두 개의 크기는 같다.

-paging의 메모리 할당
1. 스왑을 염두해두고, 페이지와 프레임을 보조기억장치의 1 block과 크기를 같게한다. (과거에)
2. 어드레스 트렌스레이션 : pagetable을 이용해서 어드래스 변환 : 상위비트를 페이지 넘버로, 하위 비트를 페이지 오프셋으로 사용. 이를 MMU가 수행하기 위해선 세그멘테이션때와 동일하게 페이지 테이블과, PTBR(페이지 테이블의 시작주소를 가지고 있는 MMU레지스터)가 필요

얼핏보면, 숫자만 다르지 세이멘테이션과 동일해 보이지만, 여기에 중대한 차이가 있다.
왜냐면, 세그멘테이션에선 세그먼트들마다 실제 크기는 가변적이다. 그래서 바운드 레지스터(값)가 존재하는것. 하지만, 페이징에서는 페이지의 크기가 모두 일정하다. 그레서 파편화 이슈를 막을 수 있는 것이다.

하지만, paging은 그 크기가 고정되어 있기에, 외부파편화(프로세스들 마다의 요구 사이즈가 달라 발생한 파편화)는 방지하는 반면, 내부파편화(하나의 프로세스에서 필요 이상의 잉여공간을 할당받아 생기는 메모리 낭비)는 발생한다. 그래서 보통 페이지의 크기를 줄여 이런 내부파편화를 줄이려고 한다.

-page talbe : 워드 사이즈와 동일
상위 비트(페이지넘버), 하위 비트(페이지에 대한 정보, 유효성, 수정여부, readwrite등)

ex) 32bit 환경에서 페이지의 크기가 4KB라는 것은, 하위비트(페이지 오프셋)이 2^12, 즉 12개이고, 상위비트가 32-12 = 20 개란 것이다. 이경우, 페이지 테이블의 크기는 2^20 * 4B = 4MB가 된다.

-paging의 장점
1. (외부)파편화 방지 가능
2. 스와핑이 용이하다 : 보통 페이지 크기와, 보조 기억장치의 1 block의 크기를 맞추니까. 세그멘테이션의 경우는 세그멘트마다 크기가 달라 스와핑이 더 번거롭다.
3. 메모리 할당도 용이하다.

-paging의 단점
1. (내부)파편화 : 이거 아주 심각한 문제는 아니다.
2. 페이징을 거쳐서 하는 만큼, 실제론 메모리탐색을 2번하는 문제(세그멘테이션도 공유하는 문제)
3. page table이 무지 커진다. 지금이야 많이 완화 되었지만, 옛날엔 메모리 사이즈가 적었기 때문에 이를 해소하기 힘들다.

-페이지드 세그멘테이션를 해야하는 이유?
얼핏보면 페이징만 써도 되는거 같아보이지만,
결국 페이징만 한다는 것은, 프로세스에게 1개의 세그먼트를 제공한다는 것이다. 즉 멀티플 세그먼트를 할당 할 수 없다. 이를 해소하기 위해선 페이징과 세그먼테이션을 섞어야할 필요가 있다.
