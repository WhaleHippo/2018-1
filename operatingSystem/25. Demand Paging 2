-용어정리
퓨어디멘드페이징 : 초기에 피지컬공간의 페이지는 NULL, 폴트가 있을때만 페이지를 가져오기
prepaging : locality를 감안해서 인접한 페이지도 같아 가져오기
reqeust paging / overay : 논리적으로 연관이 있는 page를 미리 로드하는 것

Reference bit : 메인 메모리에 로드된 page가 access되면 set되는 bit flag
Belady 모순 : 프레임을 늘렸는데 페이티 폴트는 더 발생하는 것.
스택 알고리즘 : Belady 모순이 없는 알고리즘, OPT, LRU

-내용정리
1. 페이지 선택 정책 : 어떤 페이지를 불러올 것인가?
2. 페이지 교체 정책 : 어떤 페이지를 내보낼 것인가?
3. 페이지 교체 스타일 : 모든 페이지를 대상으로 할것인가, 아님 특정 페이지만 대상인가?
4. 페이지 할당 정책 : 페이지를 프로세스에게 할당할 때 정적? 동적?


-페이지 선택 정책
퓨어 디멘드 페이징 : 초기에 페이지 0, 페이지 폴트가 있을때만 페이지를 가져오기
될 수 있으면 미리 예측해서 가져오면 좋다. -> prepaging
prepaging : locality를 감안해서 인접한 페이지도 같아 가져오기. 이걸 발전시킨게 working set
reqeust paging : 요즘은 잘 안씀

더 나아가, OS가 연관페이지를 알아서 알라주면 더 좋음. 이 개념이 바로 working set

-페이지 교체 정책 : 가장 중요한 정책임
페이지를 불러올때, 피지컬 메모리가 꽉차면 기존것들을 없애야한다.
0. 랜덤 : 막장인 방법. 그래도 가끔씩 씀. H/W적으로 구현 할때는 이게 나쁘지 않음.
1. FIFO : 먼저 들어온 놈을 먼저 내보내는 것. Belady 모순이 있지만 그래도 약간 보완해서 씀.
2. OPT : 가장 오래동안 안쓰일 놈을 교체. 미래를 예측해야 하니 구현은 불가;
3. LRU : 가장 오래동안 안쓰인 놈을 교체. 과거에 대한 OPT. Locaiity에 기반. 구현은 힘듬; 그래서 근사 알고리즘들을 구현해서 씀(세컨드 찬스)
4. LRU 근사 : 
	LRU 근사 예시
	0. 시스템 카운터를 쉬프트 형태로 만들어서 사용
	1. 페이지 테이블의 비트들 중 하나를 Reference bit로 두어 주기적으로 0으로 set하고, 교체할때는 해당 bit가 0인 놈을 빼내는 걸로 한다. 
	2. 클락 알고리즘 : 1을 보다 보완
		페이지를 원형으로 배치. 클락 핸드로 페이지를 가리킨다.
		페이지 폴트시 클락 핸드가 가리키는 페이지의 레퍼런스 bit이 1이면 0으로 바꾸고, 클락핸드가 다음 페이지를 가리킴. 이과정을 반복하다가 레퍼런스 bit이 0인 페이지를 만나면 해당 페이지를 교체. 특수 케이스로, 모든 페이지의 레퍼런스 bit가 1이라면, 즉 메인메모리가 모자라면 이건 마치 fifo처럼 작동한다.
	3. Enhanced 클락 알고리즘 레퍼런스 bit말고 dirtbit도 같이 보자는 정책
		될수있으면 클린한 페이지를 빼는게 좋다. 그건 그냥 삭제하면 되니까.
		문제는 그 clean페이지가 코드페이지라면 빼는게 미친 짓임;
	4. 프레임 버퍼링 : 레퍼런스 bit를 제공하지 않으면 어쩔수 없이 FIFO를 해야함.
		이중 큐를 사용.
		used Page frame lsit : 사용중인 페이지 큐
		free page frame list : 강등 큐 : used page 큐가 다 차는데 페이지 폴트가 발생하면, 프리 페이지에서 하나 가져와서 used page에 붙인다. 그럼 free는 -1, used는 +1. 이렇게 하다가 워터마크 이상으로 개수가 내려가면, used page에서 강제로 몇개를 때서 free에다가 붙인다. 프리 페이지로 내려간 놈이 다시 엑세스되면 그대로 used page로 올린다.
		추가적인 최적화 : 프리 페이지 프레임 리스트에 있는 놈들 중 dirty한 놈들을 DMA 컨트롤러가 idle할때 스왑 공간으로 보내면 clean페이지로 바뀌어서 더 최적화가 가능
		
		
-페이지 할당 스타일
프로세스 단위로 할당(per porcess)유저단위로 할당(per job), 시스템 단위로 할당(global)
특성
global : 메모리를 지나치게 낭비하는 놈이 있으면 다른놈들이 스타베이션. 하지만 대체로 균등하다면 좋음
per process/job : 특정 프로세스가 메모리를 많이 써도 다른 프로세스나 잡이 보호됨. 하지만 그래서 개체당 최적화가 잘 안됨 -> 이걸 해소하기 위한게 다이나믹 하게 조정해야함
페이지 프레임을 많이 받았다 -> 페이지 프레임을 줄여준다.
페이지 프레임을 적게 받았다 -> 페이지 프레임을 늘려준다.
단위 시간 당 페이지 폴트 정도를 확인하면 저걸 판단할 수 있다.


