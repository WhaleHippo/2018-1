-단어 정리


-프로세스를 creat한다?
OS가 프로그램의 자료구조를 받아서 할당하는 것을 말한다. 근데 프로세스가 실행이 되려면, 파일시스템의 엑스큐터블 파일로 부터 그 프로세스의 엑스큐션스트림+스테이트를 읽어들어야한다. 그 파일시스템에서의 path를 가져온다. 이 과정을 프로그램을 로드한다고 한다. 그래서 코드 + 데이터 세그먼트를 만든다. 그리고 빈 스택 세그먼트도 만들어준다. 이상의 과정으로 메모리 스테이트에 대한 작업은 끝난다.
그다음엔, 프로세스의 정보를 담은 PCB을 만들어야한다.
마지막으론, 이렇게 생성된 PCB를 레디큐에 집어 넣으면 프로세스의 생성이 끝난다.

이게 보편적인 프로세스의 생성이다.

-UNIX의 프로세스 생성 : fork - exec - (exit) - wait
헌데 UNIX 계열의 경우는 최초의 0번 프로세스만 위와 같은 과정으로 생성하고, 그 다음의 프로세스들은 다른 방식으로 만드는데 clone이라는 기법을 사용한다. 그리고 이때, 이 복제를 수행하는 시스템콜이 바로 fork()되시겠다.

유닉스에서는 프로세스가 생성되려면, 어떤 프로세스가 fork명령어로 생성을 해야한다. 이때, 만들어준 프로세스를 패런트 프로세스, 만들어진 프로세스를 차일드 프로세스라고 한다. fork가 호출되면, OS가 fork를 호출한 패런트 프로세스를 완전히 중지시키고, 패런트 프로세스의 context들을 스냅샵을 만든다. 그리고 그 스냅샷을 그대로 카피하여, 차일드 프로세스를 만든다. 당연하지만, PCB의 프로세스의 아이디는 다르다. 그리고 이 차일드 프로세스의 PCB를 레디큐에 넣고, 패런트 프로세스로 리턴된다.

Q) fork를 통해서 context를 일일히 복제하는건 매우 비효율적인데 왜 굳이 이러나?
A) Copy On Write(COW)라는 방식을 이용하는 거다. context를 fork()시점에서는 복사하지 않고, 포인터로만 가리키고 있다가, 데이터 세그먼트에 새로운 값이 쓰여질때 복사하는 기법이다. 쉐도우 카피라고 하기도 한다.

Q) 그리고 어차피 처음만든 프로세스와 동일한 프로세스이면 기능상 똑같은데 어떻게 생성이라 말 할 수 있는가?
A) 그래서 있는게 exec()이다. exec의 파라미터가 바로 위에서 말한 파일시스템에 있는 엑스큐터블 파일의 path이다.

암튼 이렇게 exec을 하고 나면, 그때부터 차일드 프로세스는 부모 프로세스와 달라지게 된다. 그후 부모와 자식 프로세스는 한번 만나는데, 바로 wait() 시스템 콜을 호출 할때 이다.
부모 프로세스의 입장에서 wait()의 파라미터는, 자기가 생성한 차일드 프로세스의 id이다. 그 파라미터로 준 프로세스가 수행을 종료할때까지 대기하는 것이다.
자식 프로세스는 exec()을 하고나서 수행을 다 한 뒤에 exit() 시스템 콜을 하게되는데 exit()이 수행되면 OS가 그 프로세스에게 할당해준 모든 자원을 해제한다. 단, 해제가 성공적으로 되었는지 판단하기 위한 코드만을 남겨두는데, 이 코드가 시그널의 형태로 부모 프로세스에게 전달해주어 부모 프로세스는 wait()에서 깨어나 지 할일을 한다.

-shell 코드로 살펴본 프로세스의 생성과 파괴
readcmd() : 사용자에게 프롬프트를 보내주고, 명령어를 넣으라고 하는 거
이때 리턴된 커맨드의 차일드 프로세스를 만들기 위해서 fork()를 한다. fork()의 리턴값은 부모로서 호출할때는 자식의 PID, 자식으로서 부모를 카피하였을때 호출한 경우는 0 이다. 이때 컨벤젼으로서, 시스템콜은 return값이 음수면 에러상황이다.

pid가 양수면 이제 부모 프로세스는 자식 프로세스의 종료를 wait(pid)를 호출하여 기다린다.

pid가 0이면 child프로세스가 수행되는 부분이다. 엥? 0번 프로세스가 있는데 어케 그게 가능?이라고 물을 수도 있다. 당연히 child 프로세스는 pid가 0가 아니다. 그래서 이 부분은 실행이 안될수 있다고 생각될 수 있다. 그 이유는 fork의 매커니즘 때문인데, fork를 하는 순간, 부모 프로세스의 스냅샷이 찍히고, 자식 프로세스가 복사, PCB가 시작된다. 근데 부모프로세스를 그대로 카피하였으므로, 자식 프로세스는 동일한 프로그램을 수행하게 된다. 근데 자식 프로세스는 fork의 다음줄 부터 수행하게 된다. 왜냐면, 시스템콜의 수행은 인터럽트를 발생시키므로, 여기서 OS가 트릭을 하나 더 쓰는데, fork()가 자식 프로세스에게 리턴될때는 리턴 값을 0을 한다. 암튼 그래서 child는 exec을 호출하고, 작동한다.

-잡기
사실 부모프로세스가 자식프로세스의 종료를 무조건 wait하고 있진 않아도 된다.

-왜 이런 방식을 사용하는가?
추측이지만, 아마 프로세스간의 통신 때문이 아니였을까 싶다. 왜냐하면, 프로세스들의 논리적 주소와 물리적 주소는 일치하지 않기 때문에, 통신을 할 수 없었다. 파일시스템을 통한 통신을 하면 될텐데, 이 역시도 쉽진 않다. 왜냐하면 파일의 이름을 공유해야하므로, 하지만 위의 fork를 이용한 else if - else 방식을 이용하면 최소한 부모 자식간은 확실한 통신을 가능하다. 아마 당시의 기술력 문제가 크다고 생각되지만.

-프로세스의 종료
1. exit()를 이용해서 스스로가 죽는 것
2. 부모 프로세스가 자식프로세스에게 abort()시그널을 보내어 kill하는 방법
