단어 정리
Linker : 오프젝트 파일 묶기
Loader : 묶은거를 메모리에 깔기
오브젝트 파일 :
	엑스큐션 코드
	SYmbol Table : 프로그램에서 사용하는 심볼들에 대한 정보 묶음
	Relocation Table : 링커가 사용하는 정보

내용 정리
1. 링킹 프로세스
오브젝트파일의 구조 : 섹션(세그먼트)
오브젝트파일들은 비슷한 놈들끼리 모인 섹션별로 구분된다. 그리고 각섹션은 오프셋(상대위치)로 주소 위치
	텍스트 섹션 : 코드
	데이터 섹션 : 전역변수들
	BSS 섹션 : 초기화되지 않는 전역변수들이 저장되어 있다.
	기타 섹션들 : 심볼테이블, 리로케이션, 디버깅에 필요한 정보 등등

데이터 섹션과 BSS섹션 구분의 이유 : 데이터 섹션은 변수의 주소뿐만 아니라 실제 값도 저장되어야한다. 그래서 오브젝트 파일상에 그만큼의 자리를 차지한다. 하지만, BSS섹션은 변수의 주소들만 저장한다. 그래서 오브젝트 파일에선 훨씬 적은 공간만 차지해도된다.

링커는 여러 오브젝트 파일의 동일한 타입의 섹션들을 병합해서 하나로 만든다. 이때 각 섹션들의 정렬순서는 링커스크립트를 따른다. 근데 보통 디폴트로 하고 안씀ㅋ 임베디드에서나 쓰려나(작년에 딱 한번 써봄ㅇㅇ)
이렇게 엑스큐터블 파일이 만들어지지면, 로더는 그냥 읽어서 메모리에 위치시키고, PC의 엔트리포인트에 넣어주면 끝

--------여기가지가 하이레벨의 이야기--------
좀더 로우레벨로 들어가서 세세한 과정과 문제점들을 알아보자.
1. 우리는 프로그래밍 언어로 심볼을 남발하는데, 실제론 이건 죄다 010101010101로 변환될거다. 그러기에 심볼을 주소로 변환하는 과정이 필수적으로 필요하다.

2. 나아가서, 다른 파일에서의 심볼들의 위치 역시 파악할 필요가 있다(크로스 레퍼런스). 이는 링커가 해결해야하는데, 이때 심볼테이블과 리로케이션 테이블이 중요한 역할을 수행한다.
이를 해결하기 위한 방법이 바로 두번읽기다. 파일 하나에 대해서는 심볼이 주소로 바뀌는게 간단하다. PC를 기준으로 offset하여 위치하니까. 하지만, extern등으로 해당 변수나 함수가 외부에서 정의되었을 경우는 이게 불가능한다. 일단은 0x0으로 해두고, 리로케이션 테이블에 기록해둔다. 그리고 섹션들의 병합이 종료되면, 실제 위치를 알 수 있으므로 아까 리로케이션 테이블에 기록해둔 것들의 실제로 위치로 바꾼다.

이를 통해서 콘텍스트 스위칭때 배운 메모리 콘텍스트의 요소들, (코드세그먼트, 데이터 세그먼트, 스택세그먼트, 힙세그먼트)들중에서 앞의 두 개가 어떻게 생성되는지를 알 수 있다.
코드 세그먼트는 텍스트 섹션을통해 생성, 데이터 세그먼트는 데이터 섹션과 BSS 섹션의 결합. -> static storage allocation : 왜냐면 로더로 실행시 처음에 완성되고 don't touch
스텍 세그먼트와 힙 세그먼트는 로더가 알아서 잡아준다. -> dynamic storage allocaiton : 왜냐면 실행중 동적으로 변환될수 있으므로
