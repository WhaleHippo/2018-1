-단어 정리
Context Switching : 현재 수행중인 프로세스의 state를 저장하고, 다음 수행될 프로세스의 state를 불러오는 작업
Context Saving : 
OSPCBCur : OS에 있는 글로벌 변수 중 하나로, 현재 수행되고 있는 P프로세스C컨트롤B블락를 가리키는 포인터이다.
-내용 정리

-콘텍스트 스위칭 과정
콘텍스트 스위칭에 앞서서 현재 콘텍스트들을 저장할 필요가 있다. 이때 각 요소들에 대해서 생각해보자.
여기서, 대피시킨다는것은 (레지스터 -> 캐시 -> 메모리 -> 스토리지) 순으로 이동시킴을 말한다. 물론, 캐시는 예외.
	CPU : CPU레지스터들은 모조리 대피시켜야 한다. 프로세스가 바뀌면 오염된다.
	커널 : 기억하지 않아도 된다. 왜냐하면 OS가 관리하기 때문에 오염될 염려가 없다.
	메모리 : 
		1. 대피시키지 않는다. : 배치모니터 시절에는 메모리값이 유지되기에 대피하지 않아도 된다.
		2. roll in roll out : 몽땅 대피시킨다. : 유니프로그래밍시에는 모조리 대피시켜야한다.
		3. Swap in Swap out : 디그리 오브 멀티프로그래밍이 높아졌을때 대피시킨다.

구체적인 과정은 이와 같다.
	1. 인터럽트가 발생한다.
	2. 인터럽트 과정에서 현재 수행중인 인스트럭션은 마무리
	3. 인터럽트 실행
	4. PSW(프로세스 스테이트 워드)의 mode bit가 1로 바뀜
	5. IRQ#를 확인하여 인터럽트 소스(시작주소)를 확인하고 점프
	6. 인터럽트 서비스 루틴 수행
	7. 리턴주소로 복귀.
		이 과정을 수행하기 위해서, 2~5과정 사이에서 현개 값들(PC, PSW, 리턴주소)를 저장해야한다.
		여기서 PSW와 리턴 주소값은 HW가 알아서 넣어주고,
		인터럽트 서비스 루틴 처음에 그 전의 레지스터 값들을 스택에 집어넣는다.
		
OS에는 글로벌 변수가 하나 있는데, 그놈의 이름은 다름아닌 OSPCBCur라는 놈이다. 전 강의에서 말한 것처럼, PCB안에는 프로세스의 아이디, 스케쥴링 자원할당에 유용한 정보들이 존재하는데, 후자에 해당되는 놈중 하나가 스택포인터 필드이다(스택포인터 등). 그리고 위의 절차대로 진행을 하는데, 여기서 주의사항! : 나중에 복귀를 위한 스택포인터 값은 스택포인터가 주기적으로 변화하니까 그냥 그대로 스택에 넣어서는 안된다. 그러니 PCB의 스택포인터 필드에 저장한다.
이부분이 잘 이해가 안될 수도 있는데, "걍 스택에 스택포인터 값을 push하고 나중에 pop하면 되는거 아닌가?"하는 생각을 할 수도 있다. 하지만 push든 pop이든 하려면 스택의 위치를 알아야하는데, 스택포인터는 원래 CPU에 단 하나만 존재한다. 그래서 스위칭이 발생할때 스택의 위치를 파악하려면, PCB안에서 스택포인터값을 알고 있을 필요가 있다.

이 법칙(게임의 법칙)은 잘 작동하는데, 딱 하나 예외가 있다. 바로 최초로 프로세스가 만들어 질때이다. 그때는, 마치 콘텍스트 스위칭을 한번이라도 당한거처럼, fake 스택을 만들어 주면 된다.
