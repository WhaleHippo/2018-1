-단어 정리
Context Switching : 현재 수행중인 프로세스의 state를 저장하고, 다음 수행될 프로세스의 state를 불러오는 작업
Context Saving : 
Context restore :
fake stack :  
OSPCBCur : OS에 있는 글로벌 변수 중 하나로, 현재 수행되고 있는 P프로세스C컨트롤B블락를 가리키는 포인터이다.
이 포인터 안에는 StrPtr이라고 해서 스택포인터가 있다. switching 과정에서, 이 스택포인터 값을 바탕으로 이동한다. CPU에 있는 esp는 계속적으로 변화하기 때문에.
-내용 정리

-콘텍스트 스위칭 과정
콘텍스트 스위칭에 앞서서 현재 콘텍스트들을 저장할 필요가 있다. 이때 각 요소들에 대해서 생각해보자.
여기서, 대피시킨다는것은 (레지스터 -> 캐시 -> 메모리 -> 스토리지) 순으로 이동시킴을 말한다. 물론, 캐시는 예외.
	CPU : CPU레지스터들은 모조리 대피시켜야 한다. 프로세스가 바뀌면 오염된다.
	커널 : 대피하지 않아도 된다. OS가 관리하기 때문에 오염될 염려가 없다.
	메모리 : 
		1. 대피시키지 않는다. : 배치모니터 시절에는 메모리값이 유지되기에 대피하지 않아도 된다.
		2. roll in roll out : 몽땅 대피시킨다. : 유니프로그래밍시에는 모조리 대피시켜야한다.
		3. Swap in Swap out : Degree of multiprograming이 높아졌을 때 대피시킨다.

-구체적인 과정
	1. 인터럽트가 발생한다(왜냐하면 디스패처 수행에는 인터럽트가 꼭필요).
	2. 인터럽트 과정에서 현재 수행중인 인스트럭션은 마무리
	3. 하드웨어가 인터럽트 실행에 앞서 PSW, PC(레지스터에 리턴주소가 있음)를 저장해줌.
	4. 인터럽트 시작
	5. PSW(프로세스 스테이트 워드)의 mode bit가 1로 바뀜
	6. IRQ#를 확인하여 인터럽트 소스(시작주소)를 확인하고 점프
	7. ISR 수행 초반부에, 디스패처가 필요한 레지스터값들을 저장해주어야함. 또한, 스택포인터의 값은 PCB에다 저장해 주어야함.
	(context saving 끝)
	8. ISR 수행 : 어떤 프로세스를 다음 스케쥴할건지 OSPCBCur로 PCB를 가리킴
	(context switching 끝)
	9. 스택의 내용을 모조리 pop하여 해당 프로세스의 스테이트를 복구.
	(context restore)
		
이 법칙(게임의 법칙)은 잘 작동하는데, 딱 하나 예외가 있다. 바로 최초로 프로세스가 만들어 질때이다. 그때는, 마치 콘텍스트 스위칭을 한번이라도 당한거처럼, fake 스택을 만들어 주면 된다.
